# AGENTS.md

## 思考ガイドライン

思考は英語で行い、最終的な出力は必ず日本語で提供してください。

## ツール使用ガイドライン

### コード調査

ソースコードを調査する際は、**必ずlsmcp (Language Service Protocol MCP) ツールを使用すること**。

1. **lsmcpの利点:**
   * LSP (Language Server Protocol) を活用した正確なコード解析
   * シンボル定義、参照、型情報の取得
   * プロジェクト全体の構造把握
   * コード補完やリファクタリングのサポート

2. **使用すべき場面:**
   * 関数やメソッドの定義を探す
   * 変数や型の使用箇所を調べる
   * プロジェクトの構造を理解する
   * コードの依存関係を追跡する
   * リファクタリングや変更の影響範囲を確認する

## Web検索ポリシー

### 01 検索ツール

* デフォルト: 最新ニュースクエリ（例：「今日の出来事」）を含め、**常に**最初に`gemini -p`を使用してください。

### 02 プロンプト形式

CodexにWeb検索を指示する際は、以下の形式を使用してください：

```sh
gemini -p "WebSearch: <検索クエリ>"
```

構造化された出力を強制するために、複数行のプロンプトを使用することもできます：

```sh
gemini -p $'以下の要件を満たしてください:\n\
- 必ずWeb検索を実行し、少なくとも3つのソースURLをリストアップすること\n\
- 重要なポイントを箇条書きで要約すること\n\
調査するトピック: "<トピック>"'
```

`gemini -p`（または適切な場合は`brave-search`）を明示的に指定することで、**最新のWeb検索結果を使用した回答**を得やすくなります。

### 03 エラー処理

* Gemini CLIの使用時に`429 Resource exhausted`エラーが発生した場合、すぐにリトライせず、レート制限に達することを避けるため試行を中止してください。

### 04 出力要件

* 回答にはソースを含める必要があり、これによってより信頼性が高く、検証しやすくなります。
* これらのルールに従うことで、Codexのプロンプト品質の安定化に役立ちます。

## Go コーディングガイド

原則:

* **目標設定:** コードの真の目標は、読者、メンテナー、そして将来の自分自身にとっての摩擦を減らし、コードを**明白で安全で、前進させやすい**ものにすることである 。
* **コードレビューの役割:** 変数の命名、エラー処理、インターフェースに関する懸念は、Goの設計哲学を反映したものであり、正しいGoの書き方を学ぶ場である。

### 01 エラー処理 (Handle Errors)

エラー処理はGoのコントラクトであり、適切に処理する必要がある 。

1. **エラーの無視や破棄を避ける:**
    * 結果を黙って破棄する (`_, := pickRandom(input)`)、またはエラーを無視する (`if err != nil { }`) のは悪い例とされる。
    * エラーを飲み込んでしまう（`if err != nil { return nil }`）のも避ける。
2. **二重報告を避ける:** エラーをログに記録する、または返すかのどちらかにする。**両方は行わない**。
3. **エラーにコンテキストを追加する:** エラーを返す際は、コンテキスト（文脈）情報を含める（例: `return fmt.Errorf("pickRandom failed: %w", err)`）。
4. **呼び出し元のために最適化する (Optimize for the Caller):**
    * 結果が有効で安全に使用できる場合は **`return result, nil`**。
    * 結果が無効でありエラー処理が必要な場合は **`return nil, err`**。
    * **`return nil, nil`**（曖昧なケースで追加のnilチェックを強制する）や、**`return result, err`**（どちらの値を信用すべきか不明確）は避けるべきである。ただし、部分的な結果を返す必要がある場合は、明示的に文書化すること。

### 02 インターフェースの早期追加 (Adding Interfaces Too Soon)

インターフェースは必要なときまで導入を遅らせる。

1. **具象型から始める:** インターフェースは、**複数の互換性のある型**が本当に必要になったときに初めて導入を検討する。
2. **慣例に従う:** **インターフェースを受け入れ、具象型を返す** (`accept interfaces, return concrete types`)。
3. **時期尚早な抽象化の回避:** Javaのようなオブジェクト指向パターンに早期に従うことで、不必要な複雑さが加わるのを避ける。
4. **テストのためだけのインターフェース作成を避ける:**
    * テストのためにプロダクションコードにエスケープハッチを導入しない。
    * 依存関係をモックに過度に依存する手法は、型の表現力を弱め、可読性を低下させる可能性がある。
    * 可能であれば、実際のインプリメンテーション（例: `grpctest`, `miniredis`）を用いてテストすることを優先する。ただし、Postgresなどの代替手段がない依存関係の場合、テストがないよりはインターフェースを作成する方が良い場合もある。
5. **リトマス試験:** インターフェースなしでコードが書けるのであれば、おそらくインターフェースは必要ない。

### 03 チャネルより先にミューテックス (Mutexes Before Channels)

同時実行性の複雑さを管理する際は、シンプルなアプローチから始める。

1. **シンプルなものから始める:** プロダクション環境では、**シンプルな方が安全**である 。
2. **ボトルネックの特定:** まず同期コードから始め、プロファイリングでボトルネックが示された場合にのみゴルーチンを追加する 。
3. **共有状態の同期:** 共有状態に対しては、`sync.Mutex` や `sync.WaitGroup` を使用する 。
4. **チャネルの役割:** チャネルは複雑なオーケストレーションに優れており、基本的な同期に使用すべきではない 。
5. **データ競合の検出:** `go test -race` を使用してデータ競合を見つけること 。

### 04 宣言は使用箇所に近い場所に (Declare Close to Usage)

識別子（変数、定数、関数、型など）は、必要な場所に宣言し、スコープを最小限に抑える。

1. **局所性の原則:** 識別子を必要とするファイル内で宣言する 。
2. **エクスポートの制限:** 識別子がパッケージ外で必要になった場合のみエクスポートする 。
3. **変数スコープの制限:** 関数内では、変数が消費される場所にできるだけ近くで宣言する 。
    * 代入のスコープを制限するために、`if` ステートメント内で変数を宣言することを推奨する（例: `if err := json.Unmarshal(b, &v); err != nil { ... }`） 。
4. **関連コードを近くに保つ:** 関連するコードを近くに保つことで、スコープが小さくなり、シャドウイングなどの微妙なバグが減り、リファクタリングが容易になる 。

### 05 ランタイムパニックの回避 (Avoid Runtime Panics)

防御的な設計により、制御できない入力によるパニックを防ぐ。

1. **入力のチェック:** リクエストや外部ストアなど、**外部から来るデータ**は最初に検証する 。
2. **ポインタの安全性:** 明示的なデリファレンス（間接参照）の必要性を排除するように設計する（ポインタの使用を避ける）のが最善のポインタ安全性である 。
3. **Nilチェックのバランス:**
    * 制御できない入力に対しては、パニックを防ぐためにnilチェックを行う（例: `if req == nil { return }`） 。
    * ただし、コードを無限の `if x == nil` チェックで乱雑にしない 。フローを制御できる場合は、Goのエラー処理を信頼する 。

### 06 インデントの最小化 (Minimize Indentation)

コード構造をフラットに保ち、可読性を高める。

1. **早期リターンの採用 (Return Early):**
    * すべてのロジックを `if err := doSomething(); err == nil { ... }` の内側にラップするのを避ける 。
    * 代わりに、エラーや前提条件の失敗をすぐに返すことで、構造をよりフラットにする（例: `if err != nil { return err }`） 。

### 07 キャッチオールなパッケージやファイルの回避 (Avoid Catch-All Packages and Files)

汎用的な名前のパッケージやファイルを避け、コードの目的を明確にする。

1. **汎用的な名前の回避:** `util.go`, `misc.go`, `constants.go`, `interfaces/interfaces.go` のようなファイルやパッケージを避ける。
2. **階層よりも局所性を優先:** コードはそれが影響するものの近くにある方が理解しやすい 。
3. **具体的な命名:** ドメインまたは機能に基づいて具体的に命名する 。
4. **グループ化の基準:** 型ではなく、意味でグループ化する 。

### 08 宣言を重要度順に並べる (Order Declarations by Importance)

ファイルの可読性を高めるために、重要な要素を先に配置する。

1. **最も重要なコードを上部に:** Goでは関数を使用前に宣言する必要はないが、可読性のために宣言順序は依然として重要である。
2. **順序の原則:**
    * エクスポートされた、APIに面する関数を最初に配置する 。
    * その後に、実装の詳細であるヘルパー関数を続ける 。
    * **依存関係ではなく、重要度順**に関数を並べる 。

### 09 良い命名 (Name Well)

変数名やパッケージ名が、その内容と呼び出し側での読み方を明確に伝えるようにする。

1. **型サフィックスの回避:** 変数名は**内容**を説明すべきであり、**型**を説明すべきではない 。
    * 悪い例: `userMap`, `idStr` 。
    * 良い例: `userByID`, `id` 。
2. **変数名の長さとスコープ:** 変数の宣言と使用のスコープが広くなるほど、短くまたは不可解な名前を付けるべきではない 。
3. **呼び出し側での読み方:** パッケージ名やエクスポートされた識別子を命名する際は、呼び出し側でコードがどのように読まれるかを考慮する 。

### 10 なぜ (Why) を文書化し、何を (What) ではない (Document the Why, Not the What)

コメントやプルリクエストでは、コードが**何をしているか**ではなく、**なぜそうしているか**を説明する。

1. **目的の伝達:** コメントを書く際の目標は、コードの動作を再述するのではなく、**意図や目的**を伝えることである 。
2. **存在理由の正当化:** コードコメントは、その変更がなぜ必要であり、どのように問題を解決しているのかを説明するべきである 。
3. **将来の読者への配慮:** 読者は通常、コードが何をするかは理解できるが、**なぜそれが書かれたのか**を理解するのに苦労することが多いため、その動機を文書化する。

### 11 any 型の使用 (Use any Instead of interface{})

Go 1.18以降では、`interface{}` の代わりに `any` を使用する。

1. **any を使用する:** `interface{}` の代わりに `any` を使用することで、コードがより読みやすくなる。
    * 悪い例: `map[string]interface{}`, `func Process(data interface{}) error`
    * 良い例: `map[string]any`, `func Process(data any) error`
2. **理由:** `any` は `interface{}` の型エイリアスであり、完全に同じ機能を持つが、より簡潔で読みやすい。
3. **Linterの警告回避:** `golangci-lint` の `efaceany` ルールは `interface{}` の使用に警告を出すため、`any` を使用することで警告を回避できる。
4. **適用箇所:**
    * 関数の引数・戻り値: `func(data any)`
    * マップの値: `map[string]any`
    * スライス: `[]any`
    * 構造体のフィールド: `type Config struct { Data any }`
